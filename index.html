<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest of Harvest: Legends</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            user-select: none;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .hud-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #555;
            padding: 10px;
            border-radius: 8px;
            pointer-events: auto;
        }
        #stats-bar {
            top: 10px;
            left: 10px;
            width: 250px;
        }
        /* „ÇØ„É©„Ç¶„Éâ„Çª„Éº„ÉñÁî®„É°„Éã„É•„Éº */
        #system-menu {
            top: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
        }
        .btn {
            background: #444;
            color: white;
            border: 1px solid #777;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .btn:hover { background: #666; }
        .btn:active { background: #222; }

        #hotbar {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
        }
        .hotbar-slot {
            width: 50px;
            height: 50px;
            border: 2px solid #777;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            position: relative;
        }
        .hotbar-slot.active {
            border-color: #ffd700;
            box-shadow: 0 0 10px #ffd700;
        }
        .slot-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 0 #000;
        }
        .bar-container {
            width: 100%;
            height: 10px;
            background: #333;
            margin-bottom: 5px;
            position: relative;
        }
        .bar-fill {
            height: 100%;
            width: 100%;
            transition: width 0.2s;
        }
        .hp-fill { background: #e74c3c; }
        .xp-fill { background: #f1c40f; }
        
        #log-area {
            bottom: 100px;
            left: 10px;
            width: 300px;
            height: 150px;
            overflow: hidden;
            display: flex;
            flex-direction: column-reverse;
            font-size: 14px;
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
        }
        .log-msg { margin-top: 4px; opacity: 0.9; }
        .damage-text {
            position: absolute;
            font-weight: bold;
            font-size: 20px;
            animation: floatUp 1s ease-out forwards;
            pointer-events: none;
            text-shadow: 2px 2px 0 #000;
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.2); opacity: 0; }
        }
        
        /* „É≠„Éº„Éá„Ç£„É≥„Ç∞„Ç™„Éº„Éê„Éº„É¨„Ç§ */
        #loading-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-size: 24px;
            display: none;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <!-- Stats HUD -->
        <div id="stats-bar" class="hud-panel">
            <div style="display:flex; justify-content:space-between;">
                <span id="player-name">Hero (Lv.1)</span>
                <span id="gold-display">0 G</span>
            </div>
            <div class="bar-container" style="margin-top:5px;">
                <div id="hp-bar" class="bar-fill hp-fill"></div>
            </div>
            <div class="bar-container">
                <div id="xp-bar" class="bar-fill xp-fill" style="width: 0%"></div>
            </div>
            <div style="font-size: 12px; color: #aaa;">WASD: Move | Mouse: Aim/Action | 1-5: Items</div>
        </div>

        <!-- System Menu -->
        <div id="system-menu" class="hud-panel">
            <button class="btn" id="btn-save">‚òÅÔ∏è Save</button>
            <button class="btn" id="btn-load">‚òÅÔ∏è Load</button>
        </div>

        <!-- Combat Log -->
        <div id="log-area"></div>

        <!-- Inventory Hotbar -->
        <div id="hotbar" class="hud-panel">
            <!-- Slots generated by JS -->
        </div>

        <!-- Loading Overlay -->
        <div id="loading-overlay">Connecting to Cloud...</div>
    </div>

<!-- Firebase SDK (ES Module) -->
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, doc, setDoc, getDoc, collection } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

/**
 * Firebase Manager
 * „Çª„Éº„Éñ„Éª„É≠„Éº„ÉâÊ©üËÉΩ„ÇíÊãÖÂΩì
 */
class CloudSaveSystem {
    constructor(game) {
        this.game = game;
        this.db = null;
        this.auth = null;
        this.user = null;
        this.appId = 'quest-of-harvest'; // Default ID
        
        this.initFirebase();
    }

    async initFirebase() {
        try {
            // Áí∞Â¢ÉÂ§âÊï∞„Åã„Çâ„ÅÆË®≠ÂÆöË™≠„ÅøËæº„Åø (CanvasÁí∞Â¢ÉÁî®)
            const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
            this.appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

            if (!firebaseConfig) {
                console.warn("Firebase config not found. Cloud save disabled.");
                this.game.ui.log("Cloud save unavailable (No Config).");
                return;
            }

            const app = initializeApp(firebaseConfig);
            this.auth = getAuth(app);
            this.db = getFirestore(app);

            // Ë™çË®º„Éó„É≠„Çª„Çπ
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(this.auth, __initial_auth_token);
            } else {
                await signInAnonymously(this.auth);
            }

            onAuthStateChanged(this.auth, (user) => {
                this.user = user;
                if (user) {
                    this.game.ui.log(`Cloud Connected: ${user.uid.substring(0, 5)}...`);
                }
            });

        } catch (e) {
            console.error("Firebase Init Error:", e);
            this.game.ui.log("Cloud Connection Failed.");
        }
    }

    async saveGame() {
        if (!this.db || !this.user) {
            this.game.ui.log("Not connected to cloud.");
            return;
        }

        this.game.ui.showLoading(true, "Saving...");

        try {
            const p = this.game.player;
            
            // 1. „Éó„É¨„Ç§„É§„Éº„Éá„Éº„Çø
            const playerData = {
                x: p.x, y: p.y,
                hp: p.hp, maxHp: p.maxHp,
                xp: p.xp, level: p.level, nextLevel: p.nextLevel,
                gold: p.gold,
                inventory: p.inventory
            };

            // 2. „Éû„ÉÉ„ÉóÂ§âÊõ¥Â∑ÆÂàÜ („Éá„Éï„Ç©„É´„Éà‰ª•Â§ñ„ÅÆÁä∂ÊÖã„ÇíÊåÅ„Å§„Çø„Ç§„É´„ÅÆ„Åø‰øùÂ≠ò)
            // ÂÆπÈáèÁØÄÁ¥Ñ„ÅÆ„Åü„ÇÅ„ÄÅËÄï„Åï„Çå„Åü„ÄÅ‰ΩúÁâ©„ÅåÊ§ç„Çè„Å£„Å¶„ÅÑ„Çã„ÄÅHP„ÅåÊ∏õ„Å£„Åü„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ„Åø‰øùÂ≠ò
            const mapDiff = {};
            for (const [key, tile] of Object.entries(this.game.map)) {
                if (tile.tilled || tile.crop || (tile.object && tile.object.hp < 100 /* assuming max hp is usually small */)) {
                    mapDiff[key] = tile;
                }
            }

            const saveData = {
                player: playerData,
                mapDiff: JSON.stringify(mapDiff), // Firestore„ÅÆMapÂà∂ÈôêÂõûÈÅø„ÅÆ„Åü„ÇÅJSONÊñáÂ≠óÂàóÂåñ
                timestamp: Date.now()
            };

            // ‰øùÂ≠ò„Éë„Çπ: artifacts/{appId}/users/{userId}/saveData/slot1
            const userDocRef = doc(this.db, 'artifacts', this.appId, 'users', this.user.uid, 'saveData', 'slot1');
            await setDoc(userDocRef, saveData);

            this.game.ui.log("Game Saved to Cloud!");

        } catch (e) {
            console.error("Save Error:", e);
            this.game.ui.log("Save Failed.");
        } finally {
            this.game.ui.showLoading(false);
        }
    }

    async loadGame() {
        if (!this.db || !this.user) {
            this.game.ui.log("Not connected to cloud.");
            return;
        }

        this.game.ui.showLoading(true, "Loading...");

        try {
            const userDocRef = doc(this.db, 'artifacts', this.appId, 'users', this.user.uid, 'saveData', 'slot1');
            const docSnap = await getDoc(userDocRef);

            if (docSnap.exists()) {
                const data = docSnap.data();
                
                // 1. „Éó„É¨„Ç§„É§„ÉºÂæ©ÂÖÉ
                const pData = data.player;
                const p = this.game.player;
                p.x = pData.x; p.y = pData.y;
                p.hp = pData.hp; p.maxHp = pData.maxHp;
                p.xp = pData.xp; p.level = pData.level; p.nextLevel = pData.nextLevel;
                p.gold = pData.gold;
                p.inventory = pData.inventory; // „Ç¢„Ç§„ÉÜ„É†ÂÆöÁæ©ÂèÇÁÖß„ÅØID„ÅßË°å„ÅÜ„Åü„ÇÅ„Åù„ÅÆ„Åæ„ÅæÂæ©ÂÖÉÂèØ
                
                // 2. „Éû„ÉÉ„ÉóÂæ©ÂÖÉ
                // „Éû„ÉÉ„Éó„Çí„ÇØ„É™„Ç¢„Åó„Å¶„ÄÅÂ∑ÆÂàÜ„ÇíÈÅ©Áî®„ÄÇ
                // Ê≥®ÊÑè: ÁîüÊàê„É≠„Ç∏„ÉÉ„ÇØ„ÅØÂ∫ßÊ®ô‰æùÂ≠ò„Å™„ÅÆ„Åß„ÄÅ„ÇØ„É™„Ç¢„Åó„Å¶„ÇÇÊú™Êé¢Á¥¢È†òÂüü„ÅØÂÜçÁîüÊàê„Åï„Çå„Çã„ÄÇ
                // Êó¢Áü•„ÅÆÂ§âÊõ¥„ÅÆ„Åø‰∏äÊõ∏„Åç„Åô„Çã„ÄÇ
                if (data.mapDiff) {
                    const diff = JSON.parse(data.mapDiff);
                    Object.assign(this.game.map, diff);
                }

                // 3. „Ç´„É°„É©„É™„Çª„ÉÉ„Éà
                this.game.camera.x = p.x - this.game.canvas.width / 2;
                this.game.camera.y = p.y - this.game.canvas.height / 2;

                this.game.ui.log("Game Loaded!");
            } else {
                this.game.ui.log("No save data found.");
            }

        } catch (e) {
            console.error("Load Error:", e);
            this.game.ui.log("Load Failed.");
        } finally {
            this.game.ui.showLoading(false);
        }
    }
}


/**
 * Êã°ÂºµÂèØËÉΩ„Å™„Ç≤„Éº„É†Ë®≠ÂÆö
 */
const CONFIG = {
    tileSize: 48,
    colors: {
        grass: '#2ecc71',
        dirt: '#8d6e63',
        water: '#3498db',
        tilled: '#5d4037',
        rock: '#7f8c8d'
    }
};

// „Ç¢„Ç§„ÉÜ„É†ÂÆöÁæ©
const ITEMS = {
    sword: { id: 'sword', name: 'Iron Sword', icon: '‚öîÔ∏è', type: 'weapon', damage: 10, cooldown: 400 },
    hoe: { id: 'hoe', name: 'Farmer Hoe', icon: '‚õèÔ∏è', type: 'tool', effect: 'till', cooldown: 300 },
    potion: { id: 'potion', name: 'Health Potion', icon: 'üç∑', type: 'consumable', heal: 20 },
    seed_wheat: { id: 'seed_wheat', name: 'Wheat Seeds', icon: 'üå±', type: 'seed', crop: 'wheat' },
    wheat: { id: 'wheat', name: 'Wheat', icon: 'üåæ', type: 'material' },
    wood: { id: 'wood', name: 'Wood', icon: 'ü™µ', type: 'material' },
    stone: { id: 'stone', name: 'Stone', icon: 'ü™®', type: 'material' }
};

// ÊïµÂÆöÁæ©
const ENEMIES = {
    slime: { name: 'Slime', icon: 'üíß', hp: 30, damage: 5, speed: 80, color: '#00ff00', xp: 10 },
    bat: { name: 'Bat', icon: 'ü¶á', hp: 20, damage: 3, speed: 120, color: '#555', xp: 15 },
    skeleton: { name: 'Skeleton', icon: 'üíÄ', hp: 50, damage: 8, speed: 60, color: '#eee', xp: 25 }
};

/**
 * „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£„ÇØ„É©„Çπ
 */
class Utils {
    static random(min, max) { return Math.random() * (max - min) + min; }
    static randomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
    static distance(x1, y1, x2, y2) { return Math.sqrt((x2-x1)**2 + (y2-y1)**2); }
    static noise(x, y) {
        const sin = Math.sin(x * 12.9898 + y * 78.233);
        return (sin * 43758.5453) % 1;
    }
}

/**
 * „Ç≤„Éº„É†„Ç®„É≥„Ç∏„É≥
 */
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());

        this.lastTime = 0;
        this.camera = { x: 0, y: 0 };
        this.keys = {};
        this.mouse = { x: 0, y: 0, worldX: 0, worldY: 0, down: false };

        this.map = {}; 
        this.entities = [];
        this.particles = [];
        
        this.player = new Player(0, 0);
        this.entities.push(this.player);

        this.ui = new UI(this);
        
        // „ÇØ„É©„Ç¶„Éâ„Çª„Éº„Éñ„Ç∑„Çπ„ÉÜ„É†ÂàùÊúüÂåñ
        this.cloud = new CloudSaveSystem(this);

        window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousemove', e => {
            this.mouse.x = e.clientX;
            this.mouse.y = e.clientY;
        });
        window.addEventListener('mousedown', () => this.mouse.down = true);
        window.addEventListener('mouseup', () => this.mouse.down = false);
        
        // Save/Load Buttons
        document.getElementById('btn-save').addEventListener('click', () => this.cloud.saveGame());
        document.getElementById('btn-load').addEventListener('click', () => this.cloud.loadGame());

        requestAnimationFrame(t => this.loop(t));
        setInterval(() => this.spawnManager(), 3000);
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    loop(timestamp) {
        const dt = timestamp - this.lastTime;
        this.lastTime = timestamp;
        this.update(dt);
        this.render();
        requestAnimationFrame(t => this.loop(t));
    }

    update(dt) {
        this.mouse.worldX = this.mouse.x + this.camera.x;
        this.mouse.worldY = this.mouse.y + this.camera.y;

        this.player.update(dt, this);

        this.camera.x = this.player.x - this.canvas.width / 2;
        this.camera.y = this.player.y - this.canvas.height / 2;

        this.entities = this.entities.filter(e => !e.dead);
        this.entities.forEach(e => {
            if (e !== this.player) e.update(dt, this);
        });

        this.updateVisibleTiles();

        this.particles = this.particles.filter(p => p.life > 0);
        this.particles.forEach(p => p.update(dt));
        
        this.ui.update();
    }

    render() {
        this.ctx.fillStyle = '#111';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.save();
        this.ctx.translate(-this.camera.x, -this.camera.y);

        const startCol = Math.floor(this.camera.x / CONFIG.tileSize);
        const endCol = startCol + (this.canvas.width / CONFIG.tileSize) + 1;
        const startRow = Math.floor(this.camera.y / CONFIG.tileSize);
        const endRow = startRow + (this.canvas.height / CONFIG.tileSize) + 1;

        for (let y = startRow; y <= endRow; y++) {
            for (let x = startCol; x <= endCol; x++) {
                const tile = this.getTile(x, y);
                this.renderTile(x, y, tile);
            }
        }

        this.entities.sort((a, b) => a.y - b.y);
        this.entities.forEach(e => e.render(this.ctx));

        const mx = Math.floor(this.mouse.worldX / CONFIG.tileSize) * CONFIG.tileSize;
        const my = Math.floor(this.mouse.worldY / CONFIG.tileSize) * CONFIG.tileSize;
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(mx, my, CONFIG.tileSize, CONFIG.tileSize);

        this.particles.forEach(p => p.render(this.ctx));

        this.ctx.restore();
    }

    getTile(x, y) {
        const key = `${x},${y}`;
        if (this.map[key]) return this.map[key];

        const noiseVal = Math.abs(Utils.noise(x * 0.1, y * 0.1));
        let type = 'grass';
        let object = null;

        if (noiseVal > 0.8) {
            type = 'water';
        } else if (noiseVal > 0.7) {
            type = 'dirt';
        } else {
            const objRand = Math.random();
            if (objRand > 0.95) object = { type: 'tree', hp: 3 };
            else if (objRand > 0.98) object = { type: 'rock', hp: 5 };
        }

        this.map[key] = { type, object, crop: null, tilled: false };
        return this.map[key];
    }

    renderTile(x, y, tile) {
        const px = x * CONFIG.tileSize;
        const py = y * CONFIG.tileSize;

        if (tile.type === 'water') this.ctx.fillStyle = CONFIG.colors.water;
        else if (tile.tilled) this.ctx.fillStyle = CONFIG.colors.tilled;
        else if (tile.type === 'dirt') this.ctx.fillStyle = CONFIG.colors.dirt;
        else this.ctx.fillStyle = CONFIG.colors.grass;

        this.ctx.fillRect(px, py, CONFIG.tileSize, CONFIG.tileSize);
        this.ctx.strokeStyle = 'rgba(0,0,0,0.1)';
        this.ctx.strokeRect(px, py, CONFIG.tileSize, CONFIG.tileSize);

        if (tile.crop) {
            const growthSize = (tile.crop.stage / 3) * 20;
            this.ctx.font = `${20 + growthSize}px Arial`;
            this.ctx.textAlign = 'center';
            this.ctx.fillText(ITEMS[tile.crop.type].icon, px + CONFIG.tileSize/2, py + CONFIG.tileSize/1.2);
        }

        if (tile.object) {
            this.ctx.font = '32px Arial';
            this.ctx.textAlign = 'center';
            const icon = tile.object.type === 'tree' ? 'üå≤' : 'ü™®';
            this.ctx.fillText(icon, px + CONFIG.tileSize/2, py + CONFIG.tileSize/1.2);
        }
    }

    updateVisibleTiles() {
        // „Éá„É¢Áî®ÊàêÈï∑Âá¶ÁêÜ
        for(let i=0; i<10; i++) {
            const keys = Object.keys(this.map);
            if(keys.length === 0) return;
            const key = keys[Math.floor(Math.random() * keys.length)];
            const tile = this.map[key];
            if(tile.crop && tile.crop.stage < 3) {
                if(Math.random() < 0.05) tile.crop.stage += 0.1;
            }
        }
    }

    spawnManager() {
        if (this.entities.length > 50) return;
        const angle = Math.random() * Math.PI * 2;
        const dist = Utils.random(400, 800);
        const x = this.player.x + Math.cos(angle) * dist;
        const y = this.player.y + Math.sin(angle) * dist;
        const keys = Object.keys(ENEMIES);
        const type = keys[Math.floor(Math.random() * keys.length)];
        this.entities.push(new Enemy(x, y, ENEMIES[type]));
    }
    
    addFloatingText(text, x, y, color='#fff') {
        const el = document.createElement('div');
        el.className = 'damage-text';
        el.innerText = text;
        el.style.left = (x - this.camera.x) + 'px';
        el.style.top = (y - this.camera.y) + 'px';
        el.style.color = color;
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 1000);
    }
}

class Entity {
    constructor(x, y, size) {
        this.x = x; this.y = y; this.size = size;
        this.vx = 0; this.vy = 0; this.dead = false;
    }
    update(dt, game) {}
    render(ctx) {}
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, 20);
        this.speed = 200;
        this.maxHp = 100; this.hp = 100;
        this.xp = 0; this.level = 1; this.nextLevel = 100;
        this.gold = 0; this.invincible = 0;
        this.inventory = [
            { item: ITEMS.sword, count: 1 },
            { item: ITEMS.hoe, count: 1 },
            { item: ITEMS.potion, count: 5 },
            { item: ITEMS.seed_wheat, count: 10 }
        ];
        this.selectedSlot = 0; this.actionCooldown = 0;
    }

    update(dt, game) {
        this.vx = 0; this.vy = 0;
        if (game.keys['w'] || game.keys['arrowup']) this.vy = -1;
        if (game.keys['s'] || game.keys['arrowdown']) this.vy = 1;
        if (game.keys['a'] || game.keys['arrowleft']) this.vx = -1;
        if (game.keys['d'] || game.keys['arrowright']) this.vx = 1;

        if (this.vx !== 0 || this.vy !== 0) {
            const len = Math.sqrt(this.vx**2 + this.vy**2);
            this.vx /= len; this.vy /= len;
        }

        this.x += this.vx * this.speed * (dt/1000);
        this.y += this.vy * this.speed * (dt/1000);

        if (this.actionCooldown > 0) this.actionCooldown -= dt;
        if (game.mouse.down && this.actionCooldown <= 0) this.performAction(game);
        if (this.invincible > 0) this.invincible -= dt;
        
        for(let i=1; i<=5; i++) {
            if(game.keys[i.toString()]) this.selectedSlot = i-1;
        }
    }

    performAction(game) {
        const slot = this.inventory[this.selectedSlot];
        if (!slot || !slot.item) return;
        const item = slot.item;
        
        if (item.type === 'weapon') {
            this.actionCooldown = item.cooldown;
            const angle = Math.atan2(game.mouse.worldY - this.y, game.mouse.worldX - this.x);
            game.particles.push(new SlashEffect(this.x, this.y, angle));
            game.entities.forEach(e => {
                if (e instanceof Enemy) {
                    if (Utils.distance(this.x, this.y, e.x, e.y) < 60) e.takeDamage(item.damage, game);
                }
            });
            const tx = Math.floor(game.mouse.worldX / CONFIG.tileSize);
            const ty = Math.floor(game.mouse.worldY / CONFIG.tileSize);
            const tile = game.getTile(tx, ty);
            const tDist = Utils.distance(this.x, this.y, (tx+0.5)*CONFIG.tileSize, (ty+0.5)*CONFIG.tileSize);
            if (tDist < 100 && tile.object) {
                 tile.object.hp--;
                 game.addFloatingText("Bang!", game.mouse.worldX, game.mouse.worldY, '#aaa');
                 if(tile.object.hp <= 0) {
                     const drop = tile.object.type === 'tree' ? ITEMS.wood : ITEMS.stone;
                     game.entities.push(new ItemDrop(game.mouse.worldX, game.mouse.worldY, drop));
                     tile.object = null;
                 }
            }
        } else if (item.type === 'tool' && item.effect === 'till') {
            const tx = Math.floor(game.mouse.worldX / CONFIG.tileSize);
            const ty = Math.floor(game.mouse.worldY / CONFIG.tileSize);
            const tile = game.getTile(tx, ty);
            if (Utils.distance(this.x, this.y, game.mouse.worldX, game.mouse.worldY) < 100) {
                if (!tile.object && tile.type !== 'water') {
                    tile.tilled = true;
                    this.actionCooldown = item.cooldown;
                    game.particles.push(new DustEffect(game.mouse.worldX, game.mouse.worldY));
                }
            }
        } else if (item.type === 'seed') {
            const tx = Math.floor(game.mouse.worldX / CONFIG.tileSize);
            const ty = Math.floor(game.mouse.worldY / CONFIG.tileSize);
            const tile = game.getTile(tx, ty);
            if (tile.tilled && !tile.crop && !tile.object) {
                if (Utils.distance(this.x, this.y, game.mouse.worldX, game.mouse.worldY) < 100) {
                    tile.crop = { type: item.crop, stage: 0 };
                    slot.count--;
                    if(slot.count <= 0) this.inventory.splice(this.selectedSlot, 1);
                    this.actionCooldown = 200;
                }
            }
        } else if (item.type === 'consumable') {
            this.hp = Math.min(this.hp + item.heal, this.maxHp);
            game.addFloatingText(`+${item.heal}`, this.x, this.y - 30, '#0f0');
            slot.count--;
            if(slot.count <= 0) this.inventory.splice(this.selectedSlot, 1);
            this.actionCooldown = 500;
        }
        
        if (game.mouse.down) {
             const tx = Math.floor(game.mouse.worldX / CONFIG.tileSize);
             const ty = Math.floor(game.mouse.worldY / CONFIG.tileSize);
             const tile = game.getTile(tx, ty);
             if (tile.crop && tile.crop.stage >= 3) {
                 if (Utils.distance(this.x, this.y, game.mouse.worldX, game.mouse.worldY) < 100) {
                     game.entities.push(new ItemDrop(game.mouse.worldX, game.mouse.worldY, ITEMS[tile.crop.type]));
                     tile.crop = null;
                     tile.tilled = false; 
                 }
             }
        }
    }

    takeDamage(amount, game) {
        if (this.invincible > 0) return;
        this.hp -= amount;
        game.addFloatingText(`-${amount}`, this.x, this.y - 30, '#f00');
        this.invincible = 1000;
        if (this.hp <= 0) {
            game.ui.log("GAME OVER. Refresh to restart.");
            this.dead = true;
        }
    }
    
    gainXp(amount, game) {
        this.xp += amount;
        if(this.xp >= this.nextLevel) {
            this.level++;
            this.xp -= this.nextLevel;
            this.nextLevel = Math.floor(this.nextLevel * 1.5);
            this.maxHp += 20;
            this.hp = this.maxHp;
            game.ui.log(`Level Up! Lv.${this.level}`);
            game.addFloatingText("LEVEL UP!", this.x, this.y - 50, '#ff0');
        }
    }

    addItem(item, count=1, game) {
        const existing = this.inventory.find(s => s.item.id === item.id);
        if (existing) {
            existing.count += count;
        } else {
            if (this.inventory.length < 8) this.inventory.push({ item: item, count: count });
            else { game.ui.log("Inventory full!"); return false; }
        }
        game.ui.log(`Got ${item.name} x${count}`);
        return true;
    }

    render(ctx) {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(this.x, this.y + 15, 15, 8, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#3498db';
        if (this.invincible > 0 && Math.floor(Date.now() / 100) % 2 === 0) ctx.fillStyle = '#fff';
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();

        const slot = this.inventory[this.selectedSlot];
        if (slot && slot.item) {
             ctx.font = '20px Arial';
             ctx.textAlign = 'center';
             ctx.fillText(slot.item.icon, this.x + 20, this.y);
        }
    }
}

class Enemy extends Entity {
    constructor(x, y, typeData) {
        super(x, y, 18);
        this.typeData = typeData;
        this.hp = typeData.hp; this.maxHp = typeData.hp;
        this.attackCooldown = 0;
    }
    update(dt, game) {
        const dist = Utils.distance(this.x, this.y, game.player.x, game.player.y);
        if (dist < 400 && dist > 20) {
            const angle = Math.atan2(game.player.y - this.y, game.player.x - this.x);
            // „Çπ„Éî„Éº„Éâ„ÅØÁßíÈñì„Éî„ÇØ„Çª„É´
            this.x += Math.cos(angle) * this.typeData.speed * (dt/1000);
            this.y += Math.sin(angle) * this.typeData.speed * (dt/1000);
        }
        if (dist < 30 && this.attackCooldown <= 0) {
            game.player.takeDamage(this.typeData.damage, game);
            this.attackCooldown = 1000;
        }
        if (this.attackCooldown > 0) this.attackCooldown -= dt;
    }
    takeDamage(amount, game) {
        this.hp -= amount;
        game.addFloatingText(amount, this.x, this.y - 20, '#fff');
        const angle = Math.atan2(this.y - game.player.y, this.x - game.player.x);
        this.x += Math.cos(angle) * 30;
        this.y += Math.sin(angle) * 30;
        if (this.hp <= 0) {
            this.dead = true;
            game.player.gainXp(this.typeData.xp, game);
            if (Math.random() < 0.3) game.entities.push(new ItemDrop(this.x, this.y, ITEMS.potion));
            if (Math.random() < 0.2) game.entities.push(new ItemDrop(this.x, this.y, ITEMS.seed_wheat));
            game.player.gold += Utils.randomInt(1, 10);
        }
    }
    render(ctx) {
        const hpPct = this.hp / this.maxHp;
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x - 20, this.y - 35, 40, 5);
        ctx.fillStyle = '#0f0';
        ctx.fillRect(this.x - 20, this.y - 35, 40 * hpPct, 5);
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(this.x, this.y + 15, 15, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.font = '30px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.typeData.icon, this.x, this.y);
    }
}

class ItemDrop extends Entity {
    constructor(x, y, item) {
        super(x, y, 10);
        this.item = item;
        this.bobOffset = Math.random() * 100;
    }
    update(dt, game) {
        const dist = Utils.distance(this.x, this.y, game.player.x, game.player.y);
        if (dist < 30) {
            if (game.player.addItem(this.item, 1, game)) this.dead = true;
        }
    }
    render(ctx) {
        const bob = Math.sin((Date.now() / 200) + this.bobOffset) * 5;
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(this.item.icon, this.x, this.y + bob);
        ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 15, 0, Math.PI*2);
        ctx.fill();
    }
}

class SlashEffect {
    constructor(x, y, angle) {
        this.x = x; this.y = y; this.angle = angle;
        this.life = 150; 
    }
    update(dt) { this.life -= dt; }
    render(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, 40, -Math.PI/4, Math.PI/4);
        ctx.stroke();
        ctx.restore();
    }
}

class DustEffect {
    constructor(x, y) {
        this.x = x; this.y = y; this.life = 500; this.size = 0;
    }
    update(dt) { this.life -= dt; this.size += dt * 0.05; }
    render(ctx) {
        ctx.fillStyle = `rgba(100, 80, 50, ${this.life/500})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill();
    }
}

class UI {
    constructor(game) {
        this.game = game;
        this.hotbarEl = document.getElementById('hotbar');
        this.hpBar = document.getElementById('hp-bar');
        this.xpBar = document.getElementById('xp-bar');
        this.goldDisplay = document.getElementById('gold-display');
        this.playerInfo = document.getElementById('player-name');
        this.logArea = document.getElementById('log-area');
        this.loadingOverlay = document.getElementById('loading-overlay');
        this.lastInvHash = '';
    }

    update() {
        const p = this.game.player;
        this.hpBar.style.width = `${(p.hp / p.maxHp) * 100}%`;
        this.xpBar.style.width = `${(p.xp / p.nextLevel) * 100}%`;
        this.goldDisplay.innerText = `${p.gold} G`;
        this.playerInfo.innerText = `Hero (Lv.${p.level})`;

        const invHash = JSON.stringify(p.inventory) + p.selectedSlot;
        if (invHash !== this.lastInvHash) {
            this.renderHotbar();
            this.lastInvHash = invHash;
        }
    }

    renderHotbar() {
        this.hotbarEl.innerHTML = '';
        const p = this.game.player;
        for(let i=0; i<8; i++) {
            const slotData = p.inventory[i];
            const div = document.createElement('div');
            div.className = `hotbar-slot ${i === p.selectedSlot ? 'active' : ''}`;
            if (slotData) {
                div.innerText = slotData.item.icon;
                const count = document.createElement('span');
                count.className = 'slot-count';
                count.innerText = slotData.count > 1 ? slotData.count : '';
                div.appendChild(count);
                div.onclick = () => { p.selectedSlot = i; };
            }
            if (i < 5) {
                const keyNum = document.createElement('div');
                keyNum.style.position = 'absolute';
                keyNum.style.top = '2px';
                keyNum.style.left = '2px';
                keyNum.style.fontSize = '10px';
                keyNum.style.color = '#aaa';
                keyNum.innerText = i + 1;
                div.appendChild(keyNum);
            }
            this.hotbarEl.appendChild(div);
        }
    }

    log(msg) {
        const div = document.createElement('div');
        div.className = 'log-msg';
        div.innerText = `> ${msg}`;
        this.logArea.prepend(div);
        if (this.logArea.children.length > 5) this.logArea.lastChild.remove();
    }

    showLoading(show, msg="Loading...") {
        this.loadingOverlay.style.display = show ? 'flex' : 'none';
        this.loadingOverlay.innerText = msg;
    }
}

// Start Game
const game = new Game();

</script>
</body>
</html>
